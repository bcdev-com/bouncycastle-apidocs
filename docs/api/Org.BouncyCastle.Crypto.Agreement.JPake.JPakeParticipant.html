<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Class JPakeParticipant | BouncyCastle Docs </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Class JPakeParticipant | BouncyCastle Docs ">
      
      <meta name="description" content="A participant in a Password Authenticated Key Exchange by Juggling (J-PAKE) exchange. The J-PAKE exchange is defined by Feng Hao and Peter Ryan in the paper  &amp;quot;Password Authenticated Key Exchange by Juggling, 2008.&amp;quot; The J-PAKE protocol is symmetric. There is no notion of a client or server, but rather just two participants. An instance of JPakeParticipant represents one participant, and is the primary interface for executing the exchange. To execute an exchange, construct a JPakeParticipant on each end, and call the following 7 methods (once and only once, in the given order, for each participant, sending messages between them as described): CreateRound1PayloadToSend() - and send the payload to the other participant ValidateRound1PayloadReceived(JPakeRound1Payload) - use the payload received from the other participant CreateRound2PayloadToSend() - and send the payload to the other participant ValidateRound2PayloadReceived(JPakeRound2Payload) - use the payload received from the other participant CalculateKeyingMaterial() CreateRound3PayloadToSend(BigInteger) - and send the payload to the other participant ValidateRound3PayloadReceived(JPakeRound3Payload, BigInteger) - use the payload received from the other participant Each side should derive a session key from the keying material returned by CalculateKeyingMaterial(). The caller is responsible for deriving the session key using a secure key derivation function (KDF). Round 3 is an optional key confirmation process. If you do not execute round 3, then there is no assurance that both participants are using the same key. (i.e. if the participants used different passwords, then their session keys will differ.) If the round 3 validation succeeds, then the keys are guaranteed to be the same on both sides. The symmetric design can easily support the asymmetric cases when one party initiates the communication. e.g. Sometimes the round1 payload and round2 payload may be sent in one pass. Also, in some cases, the key confirmation payload can be sent together with the round2 payload. These are the trivial techniques to optimize the communication. The key confirmation process is implemented as specified in NIST SP 800-56A Revision 1, Section 8.2 Unilateral Key Confirmation for Key Agreement Schemes. This class is stateful and NOT threadsafe. Each instance should only be used for ONE complete J-PAKE exchange (i.e. a new JPakeParticipant should be constructed for each new J-PAKE exchange).">
      <link rel="icon" href="../favicon.ico">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      
      
      
      
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="ManagedReference">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../logo.svg" alt="BouncyCastle Docs">
            BouncyCastle Docs
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="Org.BouncyCastle.Crypto.Agreement.JPake.JPakeParticipant">



  <h1 id="Org_BouncyCastle_Crypto_Agreement_JPake_JPakeParticipant" data-uid="Org.BouncyCastle.Crypto.Agreement.JPake.JPakeParticipant" class="text-break">
Class JPakeParticipant  
  </h1>

  <div class="facts text-secondary">
    <dl><dt>Namespace</dt><dd><a class="xref" href="Org.html">Org</a>.<a class="xref" href="Org.BouncyCastle.html">BouncyCastle</a>.<a class="xref" href="Org.BouncyCastle.Crypto.html">Crypto</a>.<a class="xref" href="Org.BouncyCastle.Crypto.Agreement.html">Agreement</a>.<a class="xref" href="Org.BouncyCastle.Crypto.Agreement.JPake.html">JPake</a></dd></dl>
  <dl><dt>Assembly</dt><dd>BouncyCastle.Cryptography.dll</dd></dl>
  </div>

  <div class="markdown summary"><p>A participant in a Password Authenticated Key Exchange by Juggling (J-PAKE) exchange.</p>
<p>The J-PAKE exchange is defined by Feng Hao and Peter Ryan in the paper
<a href="http://grouper.ieee.org/groups/1363/Research/contributions/hao-ryan-2008.pdf">
&quot;Password Authenticated Key Exchange by Juggling, 2008.&quot;</a></p>
<p>The J-PAKE protocol is symmetric.
There is no notion of a <i>client</i> or <i>server</i>, but rather just two <i>participants</i>.
An instance of JPakeParticipant represents one participant, and
is the primary interface for executing the exchange.</p>
<p>To execute an exchange, construct a JPakeParticipant on each end,
and call the following 7 methods
(once and only once, in the given order, for each participant, sending messages between them as described):</p>
<p>CreateRound1PayloadToSend() - and send the payload to the other participant
ValidateRound1PayloadReceived(JPakeRound1Payload) - use the payload received from the other participant
CreateRound2PayloadToSend() - and send the payload to the other participant
ValidateRound2PayloadReceived(JPakeRound2Payload) - use the payload received from the other participant
CalculateKeyingMaterial()
CreateRound3PayloadToSend(BigInteger) - and send the payload to the other participant
ValidateRound3PayloadReceived(JPakeRound3Payload, BigInteger) - use the payload received from the other participant</p>
<p>Each side should derive a session key from the keying material returned by CalculateKeyingMaterial().
The caller is responsible for deriving the session key using a secure key derivation function (KDF).</p>
<p>Round 3 is an optional key confirmation process.
If you do not execute round 3, then there is no assurance that both participants are using the same key.
(i.e. if the participants used different passwords, then their session keys will differ.)</p>
<p>If the round 3 validation succeeds, then the keys are guaranteed to be the same on both sides.</p>
<p>The symmetric design can easily support the asymmetric cases when one party initiates the communication.
e.g. Sometimes the round1 payload and round2 payload may be sent in one pass.
Also, in some cases, the key confirmation payload can be sent together with the round2 payload.
These are the trivial techniques to optimize the communication.</p>
<p>The key confirmation process is implemented as specified in
<a href="http://csrc.nist.gov/publications/nistpubs/800-56A/SP800-56A_Revision1_Mar08-2007.pdf">NIST SP 800-56A Revision 1</a>,
Section 8.2 Unilateral Key Confirmation for Key Agreement Schemes.</p>
<p>This class is stateful and NOT threadsafe.
Each instance should only be used for ONE complete J-PAKE exchange
(i.e. a new JPakeParticipant should be constructed for each new J-PAKE exchange).</p>
</div>
  <div class="markdown conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public class JPakeParticipant</code></pre>
  </div>




  <dl class="typelist inheritance">
    <dt>Inheritance</dt>
    <dd>
      <div><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.object">object</a></div>
      <div><span class="xref">JPakeParticipant</span></div>
    </dd>
  </dl>



  <dl class="typelist inheritedMembers">
    <dt>Inherited Members</dt>
    <dd>
    <div>
      <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.object.equals#system-object-equals(system-object)">object.Equals(object)</a>
    </div>
    <div>
      <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.object.equals#system-object-equals(system-object-system-object)">object.Equals(object, object)</a>
    </div>
    <div>
      <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.object.gethashcode">object.GetHashCode()</a>
    </div>
    <div>
      <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.object.gettype">object.GetType()</a>
    </div>
    <div>
      <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.object.memberwiseclone">object.MemberwiseClone()</a>
    </div>
    <div>
      <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.object.referenceequals">object.ReferenceEquals(object, object)</a>
    </div>
    <div>
      <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.object.tostring">object.ToString()</a>
    </div>
  </dd></dl>






  <h2 class="section" id="constructors">Constructors
</h2>


  <a id="Org_BouncyCastle_Crypto_Agreement_JPake_JPakeParticipant__ctor_" data-uid="Org.BouncyCastle.Crypto.Agreement.JPake.JPakeParticipant.#ctor*"></a>

  <h3 id="Org_BouncyCastle_Crypto_Agreement_JPake_JPakeParticipant__ctor_System_String_System_Char___" data-uid="Org.BouncyCastle.Crypto.Agreement.JPake.JPakeParticipant.#ctor(System.String,System.Char[])">
  JPakeParticipant(string, char[])
  
  </h3>

  <div class="markdown level1 summary"><p>Convenience constructor for a new JPakeParticipant that uses
the JPakePrimeOrderGroups#NIST_3072 prime order group,
a SHA-256 digest, and a default SecureRandom implementation.</p>
<p>After construction, the State state will be STATE_INITIALIZED.</p>
<p>Throws NullReferenceException if any argument is null. Throws
ArgumentException if password is empty.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public JPakeParticipant(string participantId, char[] password)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>participantId</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a></dt>
    <dd><p>Unique identifier of this participant.
The two participants in the exchange must NOT share the same id.</p>
</dd>
    <dt><code>password</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.char">char</a>[]</dt>
    <dd><p>Shared secret.
A defensive copy of this array is made (and cleared once CalculateKeyingMaterial() is called).
Caller should clear the input password as soon as possible.</p>
</dd>
  </dl>












  <a id="Org_BouncyCastle_Crypto_Agreement_JPake_JPakeParticipant__ctor_" data-uid="Org.BouncyCastle.Crypto.Agreement.JPake.JPakeParticipant.#ctor*"></a>

  <h3 id="Org_BouncyCastle_Crypto_Agreement_JPake_JPakeParticipant__ctor_System_String_System_Char___Org_BouncyCastle_Crypto_Agreement_JPake_JPakePrimeOrderGroup_" data-uid="Org.BouncyCastle.Crypto.Agreement.JPake.JPakeParticipant.#ctor(System.String,System.Char[],Org.BouncyCastle.Crypto.Agreement.JPake.JPakePrimeOrderGroup)">
  JPakeParticipant(string, char[], JPakePrimeOrderGroup)
  
  </h3>

  <div class="markdown level1 summary"><p>Convenience constructor for a new JPakeParticipant that uses
a SHA-256 digest, and a default SecureRandom implementation.</p>
<p>After construction, the State state will be STATE_INITIALIZED.</p>
<p>Throws NullReferenceException if any argument is null. Throws
ArgumentException if password is empty.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public JPakeParticipant(string participantId, char[] password, JPakePrimeOrderGroup group)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>participantId</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a></dt>
    <dd><p>Unique identifier of this participant.
The two participants in the exchange must NOT share the same id.</p>
</dd>
    <dt><code>password</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.char">char</a>[]</dt>
    <dd><p>Shared secret.
A defensive copy of this array is made (and cleared once CalculateKeyingMaterial() is called).
Caller should clear the input password as soon as possible.</p>
</dd>
    <dt><code>group</code> <a class="xref" href="Org.BouncyCastle.Crypto.Agreement.JPake.JPakePrimeOrderGroup.html">JPakePrimeOrderGroup</a></dt>
    <dd><p>Prime order group. See JPakePrimeOrderGroups for standard groups.</p>
</dd>
  </dl>












  <a id="Org_BouncyCastle_Crypto_Agreement_JPake_JPakeParticipant__ctor_" data-uid="Org.BouncyCastle.Crypto.Agreement.JPake.JPakeParticipant.#ctor*"></a>

  <h3 id="Org_BouncyCastle_Crypto_Agreement_JPake_JPakeParticipant__ctor_System_String_System_Char___Org_BouncyCastle_Crypto_Agreement_JPake_JPakePrimeOrderGroup_Org_BouncyCastle_Crypto_IDigest_Org_BouncyCastle_Security_SecureRandom_" data-uid="Org.BouncyCastle.Crypto.Agreement.JPake.JPakeParticipant.#ctor(System.String,System.Char[],Org.BouncyCastle.Crypto.Agreement.JPake.JPakePrimeOrderGroup,Org.BouncyCastle.Crypto.IDigest,Org.BouncyCastle.Security.SecureRandom)">
  JPakeParticipant(string, char[], JPakePrimeOrderGroup, IDigest, SecureRandom)
  
  </h3>

  <div class="markdown level1 summary"><p>Constructor for a new JPakeParticipant.</p>
<p>After construction, the State state will be STATE_INITIALIZED.</p>
<p>Throws NullReferenceException if any argument is null. Throws
ArgumentException if password is empty.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public JPakeParticipant(string participantId, char[] password, JPakePrimeOrderGroup group, IDigest digest, SecureRandom random)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>participantId</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a></dt>
    <dd><p>Unique identifier of this participant.
The two participants in the exchange must NOT share the same id.</p>
</dd>
    <dt><code>password</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.char">char</a>[]</dt>
    <dd><p>Shared secret.
A defensive copy of this array is made (and cleared once CalculateKeyingMaterial() is called).
Caller should clear the input password as soon as possible.</p>
</dd>
    <dt><code>group</code> <a class="xref" href="Org.BouncyCastle.Crypto.Agreement.JPake.JPakePrimeOrderGroup.html">JPakePrimeOrderGroup</a></dt>
    <dd><p>Prime order group. See JPakePrimeOrderGroups for standard groups.</p>
</dd>
    <dt><code>digest</code> <a class="xref" href="Org.BouncyCastle.Crypto.IDigest.html">IDigest</a></dt>
    <dd><p>Digest to use during zero knowledge proofs and key confirmation
(SHA-256 or stronger preferred).</p>
</dd>
    <dt><code>random</code> <a class="xref" href="Org.BouncyCastle.Security.SecureRandom.html">SecureRandom</a></dt>
    <dd><p>Source of secure random data for x1 and x2, and for the zero knowledge proofs.</p>
</dd>
  </dl>












  <h2 class="section" id="fields">Fields
</h2>



  <h3 id="Org_BouncyCastle_Crypto_Agreement_JPake_JPakeParticipant_STATE_INITIALIZED" data-uid="Org.BouncyCastle.Crypto.Agreement.JPake.JPakeParticipant.STATE_INITIALIZED">
  STATE_INITIALIZED
  
  </h3>

  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static readonly int STATE_INITIALIZED</code></pre>
  </div>




  <h4 class="section">Field Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd></dd>
  </dl>










  <h3 id="Org_BouncyCastle_Crypto_Agreement_JPake_JPakeParticipant_STATE_KEY_CALCULATED" data-uid="Org.BouncyCastle.Crypto.Agreement.JPake.JPakeParticipant.STATE_KEY_CALCULATED">
  STATE_KEY_CALCULATED
  
  </h3>

  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static readonly int STATE_KEY_CALCULATED</code></pre>
  </div>




  <h4 class="section">Field Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd></dd>
  </dl>










  <h3 id="Org_BouncyCastle_Crypto_Agreement_JPake_JPakeParticipant_STATE_ROUND_1_CREATED" data-uid="Org.BouncyCastle.Crypto.Agreement.JPake.JPakeParticipant.STATE_ROUND_1_CREATED">
  STATE_ROUND_1_CREATED
  
  </h3>

  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static readonly int STATE_ROUND_1_CREATED</code></pre>
  </div>




  <h4 class="section">Field Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd></dd>
  </dl>










  <h3 id="Org_BouncyCastle_Crypto_Agreement_JPake_JPakeParticipant_STATE_ROUND_1_VALIDATED" data-uid="Org.BouncyCastle.Crypto.Agreement.JPake.JPakeParticipant.STATE_ROUND_1_VALIDATED">
  STATE_ROUND_1_VALIDATED
  
  </h3>

  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static readonly int STATE_ROUND_1_VALIDATED</code></pre>
  </div>




  <h4 class="section">Field Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd></dd>
  </dl>










  <h3 id="Org_BouncyCastle_Crypto_Agreement_JPake_JPakeParticipant_STATE_ROUND_2_CREATED" data-uid="Org.BouncyCastle.Crypto.Agreement.JPake.JPakeParticipant.STATE_ROUND_2_CREATED">
  STATE_ROUND_2_CREATED
  
  </h3>

  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static readonly int STATE_ROUND_2_CREATED</code></pre>
  </div>




  <h4 class="section">Field Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd></dd>
  </dl>










  <h3 id="Org_BouncyCastle_Crypto_Agreement_JPake_JPakeParticipant_STATE_ROUND_2_VALIDATED" data-uid="Org.BouncyCastle.Crypto.Agreement.JPake.JPakeParticipant.STATE_ROUND_2_VALIDATED">
  STATE_ROUND_2_VALIDATED
  
  </h3>

  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static readonly int STATE_ROUND_2_VALIDATED</code></pre>
  </div>




  <h4 class="section">Field Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd></dd>
  </dl>










  <h3 id="Org_BouncyCastle_Crypto_Agreement_JPake_JPakeParticipant_STATE_ROUND_3_CREATED" data-uid="Org.BouncyCastle.Crypto.Agreement.JPake.JPakeParticipant.STATE_ROUND_3_CREATED">
  STATE_ROUND_3_CREATED
  
  </h3>

  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static readonly int STATE_ROUND_3_CREATED</code></pre>
  </div>




  <h4 class="section">Field Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd></dd>
  </dl>










  <h3 id="Org_BouncyCastle_Crypto_Agreement_JPake_JPakeParticipant_STATE_ROUND_3_VALIDATED" data-uid="Org.BouncyCastle.Crypto.Agreement.JPake.JPakeParticipant.STATE_ROUND_3_VALIDATED">
  STATE_ROUND_3_VALIDATED
  
  </h3>

  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static readonly int STATE_ROUND_3_VALIDATED</code></pre>
  </div>




  <h4 class="section">Field Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd></dd>
  </dl>









  <h2 class="section" id="properties">Properties
</h2>


  <a id="Org_BouncyCastle_Crypto_Agreement_JPake_JPakeParticipant_State_" data-uid="Org.BouncyCastle.Crypto.Agreement.JPake.JPakeParticipant.State*"></a>

  <h3 id="Org_BouncyCastle_Crypto_Agreement_JPake_JPakeParticipant_State" data-uid="Org.BouncyCastle.Crypto.Agreement.JPake.JPakeParticipant.State">
  State
  
  </h3>

  <div class="markdown level1 summary"><p>Gets the current state of this participant.
See the <tt>STATE_*</tt> constants for possible values.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual int State { get; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd></dd>
  </dl>








  <h2 class="section" id="methods">Methods
</h2>


  <a id="Org_BouncyCastle_Crypto_Agreement_JPake_JPakeParticipant_CalculateKeyingMaterial_" data-uid="Org.BouncyCastle.Crypto.Agreement.JPake.JPakeParticipant.CalculateKeyingMaterial*"></a>

  <h3 id="Org_BouncyCastle_Crypto_Agreement_JPake_JPakeParticipant_CalculateKeyingMaterial" data-uid="Org.BouncyCastle.Crypto.Agreement.JPake.JPakeParticipant.CalculateKeyingMaterial">
  CalculateKeyingMaterial()
  
  </h3>

  <div class="markdown level1 summary"><p>Calculates and returns the key material.
A session key must be derived from this key material using a secure key derivation function (KDF).
The KDF used to derive the key is handled externally (i.e. not by JPakeParticipant).</p>
<p>The keying material will be identical for each participant if and only if
each participant's password is the same.  i.e. If the participants do not
share the same password, then each participant will derive a different key.
Therefore, if you immediately start using a key derived from
the keying material, then you must handle detection of incorrect keys.
If you want to handle this detection explicitly, you can optionally perform
rounds 3 and 4.  See JPakeParticipant for details on how to execute
rounds 3 and 4.</p>
<p>The keying material will be in the range <tt>[0, p-1]</tt>.</p>
<p>ValidateRound2PayloadReceived(JPakeRound2Payload) must be called prior to this method.</p>
<p>As a side effect, the internal password array is cleared, since it is no longer needed.</p>
<p>After execution, the State state will be STATE_KEY_CALCULATED.</p>
<p>Throws InvalidOperationException if called prior to ValidateRound2PayloadReceived(JPakeRound2Payload),
or if called multiple times.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual BigInteger CalculateKeyingMaterial()</code></pre>
  </div>


  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Org.BouncyCastle.Math.BigInteger.html">BigInteger</a></dt>
    <dd></dd>
  </dl>











  <a id="Org_BouncyCastle_Crypto_Agreement_JPake_JPakeParticipant_CreateRound1PayloadToSend_" data-uid="Org.BouncyCastle.Crypto.Agreement.JPake.JPakeParticipant.CreateRound1PayloadToSend*"></a>

  <h3 id="Org_BouncyCastle_Crypto_Agreement_JPake_JPakeParticipant_CreateRound1PayloadToSend" data-uid="Org.BouncyCastle.Crypto.Agreement.JPake.JPakeParticipant.CreateRound1PayloadToSend">
  CreateRound1PayloadToSend()
  
  </h3>

  <div class="markdown level1 summary"><p>Creates and returns the payload to send to the other participant during round 1.</p>
<p>After execution, the State state} will be STATE_ROUND_1_CREATED}.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual JPakeRound1Payload CreateRound1PayloadToSend()</code></pre>
  </div>


  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Org.BouncyCastle.Crypto.Agreement.JPake.JPakeRound1Payload.html">JPakeRound1Payload</a></dt>
    <dd></dd>
  </dl>











  <a id="Org_BouncyCastle_Crypto_Agreement_JPake_JPakeParticipant_CreateRound2PayloadToSend_" data-uid="Org.BouncyCastle.Crypto.Agreement.JPake.JPakeParticipant.CreateRound2PayloadToSend*"></a>

  <h3 id="Org_BouncyCastle_Crypto_Agreement_JPake_JPakeParticipant_CreateRound2PayloadToSend" data-uid="Org.BouncyCastle.Crypto.Agreement.JPake.JPakeParticipant.CreateRound2PayloadToSend">
  CreateRound2PayloadToSend()
  
  </h3>

  <div class="markdown level1 summary"><p>Creates and returns the payload to send to the other participant during round 2.</p>
<p>ValidateRound1PayloadReceived(JPakeRound1Payload) must be called prior to this method.</p>
<p>After execution, the State state will be  STATE_ROUND_2_CREATED.</p>
<p>Throws InvalidOperationException if called prior to ValidateRound1PayloadReceived(JPakeRound1Payload), or multiple times</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual JPakeRound2Payload CreateRound2PayloadToSend()</code></pre>
  </div>


  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Org.BouncyCastle.Crypto.Agreement.JPake.JPakeRound2Payload.html">JPakeRound2Payload</a></dt>
    <dd></dd>
  </dl>











  <a id="Org_BouncyCastle_Crypto_Agreement_JPake_JPakeParticipant_CreateRound3PayloadToSend_" data-uid="Org.BouncyCastle.Crypto.Agreement.JPake.JPakeParticipant.CreateRound3PayloadToSend*"></a>

  <h3 id="Org_BouncyCastle_Crypto_Agreement_JPake_JPakeParticipant_CreateRound3PayloadToSend_Org_BouncyCastle_Math_BigInteger_" data-uid="Org.BouncyCastle.Crypto.Agreement.JPake.JPakeParticipant.CreateRound3PayloadToSend(Org.BouncyCastle.Math.BigInteger)">
  CreateRound3PayloadToSend(BigInteger)
  
  </h3>

  <div class="markdown level1 summary"><p>Creates and returns the payload to send to the other participant during round 3.</p>
<p>See JPakeParticipant for more details on round 3.</p>
<p>After execution, the State state} will be  STATE_ROUND_3_CREATED.
Throws InvalidOperationException if called prior to CalculateKeyingMaterial, or multiple
times.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual JPakeRound3Payload CreateRound3PayloadToSend(BigInteger keyingMaterial)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>keyingMaterial</code> <a class="xref" href="Org.BouncyCastle.Math.BigInteger.html">BigInteger</a></dt>
    <dd><p>The keying material as returned from CalculateKeyingMaterial().</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Org.BouncyCastle.Crypto.Agreement.JPake.JPakeRound3Payload.html">JPakeRound3Payload</a></dt>
    <dd></dd>
  </dl>











  <a id="Org_BouncyCastle_Crypto_Agreement_JPake_JPakeParticipant_ValidateRound1PayloadReceived_" data-uid="Org.BouncyCastle.Crypto.Agreement.JPake.JPakeParticipant.ValidateRound1PayloadReceived*"></a>

  <h3 id="Org_BouncyCastle_Crypto_Agreement_JPake_JPakeParticipant_ValidateRound1PayloadReceived_Org_BouncyCastle_Crypto_Agreement_JPake_JPakeRound1Payload_" data-uid="Org.BouncyCastle.Crypto.Agreement.JPake.JPakeParticipant.ValidateRound1PayloadReceived(Org.BouncyCastle.Crypto.Agreement.JPake.JPakeRound1Payload)">
  ValidateRound1PayloadReceived(JPakeRound1Payload)
  
  </h3>

  <div class="markdown level1 summary"><p>Validates the payload received from the other participant during round 1.</p>
<p>Must be called prior to CreateRound2PayloadToSend().</p>
<p>After execution, the State state will be  STATE_ROUND_1_VALIDATED.</p>
<p>Throws CryptoException if validation fails. Throws InvalidOperationException
if called multiple times.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void ValidateRound1PayloadReceived(JPakeRound1Payload round1PayloadReceived)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>round1PayloadReceived</code> <a class="xref" href="Org.BouncyCastle.Crypto.Agreement.JPake.JPakeRound1Payload.html">JPakeRound1Payload</a></dt>
    <dd></dd>
  </dl>












  <a id="Org_BouncyCastle_Crypto_Agreement_JPake_JPakeParticipant_ValidateRound2PayloadReceived_" data-uid="Org.BouncyCastle.Crypto.Agreement.JPake.JPakeParticipant.ValidateRound2PayloadReceived*"></a>

  <h3 id="Org_BouncyCastle_Crypto_Agreement_JPake_JPakeParticipant_ValidateRound2PayloadReceived_Org_BouncyCastle_Crypto_Agreement_JPake_JPakeRound2Payload_" data-uid="Org.BouncyCastle.Crypto.Agreement.JPake.JPakeParticipant.ValidateRound2PayloadReceived(Org.BouncyCastle.Crypto.Agreement.JPake.JPakeRound2Payload)">
  ValidateRound2PayloadReceived(JPakeRound2Payload)
  
  </h3>

  <div class="markdown level1 summary"><p>Validates the payload received from the other participant during round 2.
Note that this DOES NOT detect a non-common password.
The only indication of a non-common password is through derivation
of different keys (which can be detected explicitly by executing round 3 and round 4)</p>
<p>Must be called prior to CalculateKeyingMaterial().</p>
<p>After execution, the State state will be STATE_ROUND_2_VALIDATED.</p>
<p>Throws CryptoException if validation fails. Throws
InvalidOperationException if called prior to ValidateRound1PayloadReceived(JPakeRound1Payload), or multiple times</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void ValidateRound2PayloadReceived(JPakeRound2Payload round2PayloadReceived)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>round2PayloadReceived</code> <a class="xref" href="Org.BouncyCastle.Crypto.Agreement.JPake.JPakeRound2Payload.html">JPakeRound2Payload</a></dt>
    <dd></dd>
  </dl>












  <a id="Org_BouncyCastle_Crypto_Agreement_JPake_JPakeParticipant_ValidateRound3PayloadReceived_" data-uid="Org.BouncyCastle.Crypto.Agreement.JPake.JPakeParticipant.ValidateRound3PayloadReceived*"></a>

  <h3 id="Org_BouncyCastle_Crypto_Agreement_JPake_JPakeParticipant_ValidateRound3PayloadReceived_Org_BouncyCastle_Crypto_Agreement_JPake_JPakeRound3Payload_Org_BouncyCastle_Math_BigInteger_" data-uid="Org.BouncyCastle.Crypto.Agreement.JPake.JPakeParticipant.ValidateRound3PayloadReceived(Org.BouncyCastle.Crypto.Agreement.JPake.JPakeRound3Payload,Org.BouncyCastle.Math.BigInteger)">
  ValidateRound3PayloadReceived(JPakeRound3Payload, BigInteger)
  
  </h3>

  <div class="markdown level1 summary"><p>Validates the payload received from the other participant during round 3.</p>
<p>See JPakeParticipant for more details on round 3.</p>
<p>After execution, the State state will be STATE_ROUND_3_VALIDATED.</p>
<p>Throws CryptoException if validation fails. Throws InvalidOperationException if called prior to
CalculateKeyingMaterial or multiple times</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void ValidateRound3PayloadReceived(JPakeRound3Payload round3PayloadReceived, BigInteger keyingMaterial)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>round3PayloadReceived</code> <a class="xref" href="Org.BouncyCastle.Crypto.Agreement.JPake.JPakeRound3Payload.html">JPakeRound3Payload</a></dt>
    <dd><p>The round 3 payload received from the other participant.</p>
</dd>
    <dt><code>keyingMaterial</code> <a class="xref" href="Org.BouncyCastle.Math.BigInteger.html">BigInteger</a></dt>
    <dd><p>The keying material as returned from CalculateKeyingMaterial().</p>
</dd>
  </dl>













</article>

        <div class="contribution d-print-none">
        </div>


      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>


    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
